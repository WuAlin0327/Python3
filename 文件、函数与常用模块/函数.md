# 函数
* 函数是指将一组语句的集合通过一个名字（函数名）封装起来，要想执行这一个函数，只需调用其函数名即可
* 语法
```
def sayhi(): # 函数名
    print("Hello world")

sayhi() # 调用函数
```
* 特性
1. 减少重复代码
2. 使程序变的可扩展
3. 使程序变的易维护

##### 形参与实参
```
def sum(x,y): # 这个x,y为形参
    res = x*y
sum(2,5)# 这个2,5为实参
```

##### 默认参数
默认参数是定义函数是默认给它赋值的一个参数，如果不更改便调用默认值
```
def infomation(name,age,country = "中国"):
    print(name,age,couutry)
infomation("吴阿麟","22")
infomation("jack",'12','USA')

>>>吴阿麟 22 中国
>>>jack 12 USA
```
默认参数必须在最后面。

##### 关键参数
* 指定来参数名的参数为关键参数，关键参数必须放在位置参数后面
* 关键参数不能重复赋值
```
def sum(x,y,z,a=1):
    print(x,y,z,a)
sum(1,z=5,y=3) # 可正确调用

sum(1,z=5,4) # 错误调用（位置参数不能在关键参数后面）
sum(1,2,y=3) # 错误调用（参数不能重复赋值）
```
##### 非固定参数
* 如果形参中出现了‘*’，传递的参数就可以不再是固定个数，传过来的所有参数打包成元组

1. 方式一：
```
def send_alert(msg,*user)
    for i in user:
        print('报警！')
send_alert("传递内容",'alex','tom','jack') # *user可接收的参数个数是不固定的
```
2. 方式二：
```
send_alert("报警",*['alex','tom','jack'])
# 将列表中的参数原封不动打包传递到user参数中
# 如果没有列表前面的‘*’，则将列表打包到参数元组的第一个元素
```
'**'接受非固定参数，也就是没有在函数中定义的参数，将传入的参数打包成字典发送到两个星号的参数中
1. 方式一：
```
def sum(a,*b,**c):
	print(a,b,c)
sum(2,3,4,5,6,d=22,x=444,z=333)
>>>2 (3, 4, 5, 6) {'d': 22, 'x': 444, 'z': 333}
```
2. 方式二：
```
def sum(a,*b,**c):
	print(a,b,c)
s = {'str':'x'}
sum(2,**s)
>>>2 () {'str': 'x'}
```
##### 函数的返回值
* 函数外部的代码要想获取函数的执行结果，就可以在函数例用return语句把结果返回


##### 全局变量与局部变量
* 定义在函数外部一级代码的变量，叫全局变量，全局变量指整个程序可以用
* 在函数中定义的变量，叫局部变量
```
name = 'jack' # 全局变量
def change_name():
    name = 'tom' # 局部变量
    print(name)
chanfe_name()
print(name)
```
1. 局部变量只能在函数中调用，函数一旦执行完毕，局部变量失效
2. 在函数内部可以引用全局变量（在没有局部变量的时候）
3. 如果全局和局部都有一个变量，函数查找优先级由内而外

* 在局部变量中修改全局变量
```
name = 'jack' # 全局变量
def change_name():
    global name# 允许函数修改全局变量
    name = 'tom' # 局部变量
    print(name)
chanfe_name()
print(name)
```
1. global只能声明在修改之前
2. 不推荐使用global
* 在函数里修改列表数据
```
names = ['jack','tom',jom]
def change_name():
    del namse[2]
    print(names)
change_name()
print(names)
>>>['jack', 'tom']
>>>['jack', 'tom']
```
1. 列表、字典、对象在函数内部元素是可以修改的，但整体是不能修改的
2. 字符串，数字是不能被修改的

##### 嵌套函数


##### 函数的作用域
* 在python中一个函数就是一个作用域
1. C# Java中的作用域{}
2. 所有的局部变量放置在其函数作用域中
3. 代码定义完成后，作用域已经生成，作用域链向上查找
4. 不论函数在哪调用，函数都会回到原来的作用域向上查找

##### 匿名函数
* 作用
1. 节省代码量
2. 看着高级
```
def calc(x,y):
    if  x < y:
        return x**y
    else:
        return x/y
func = lambda x,y: x*y if x<y else x/y #声明一个匿名函数
calc(16,8)
func(16,8)
```