# 函数
* 函数是指将一组语句的集合通过一个名字（函数名）封装起来，要想执行这一个函数，只需调用其函数名即可
* 语法
```
def sayhi(): # 函数名
    print("Hello world")

sayhi() # 调用函数
```
* 特性
1. 减少重复代码
2. 使程序变的可扩展
3. 使程序变的易维护

##### 形参与实参
```
def sum(x,y): # 这个x,y为形参
    res = x*y
sum(2,5)# 这个2,5为实参
```

##### 默认参数
默认参数是定义函数是默认给它赋值的一个参数，如果不更改便调用默认值
```
def infomation(name,age,country = "中国"):
    print(name,age,couutry)
infomation("吴阿麟","22")
infomation("jack",'12','USA')

>>>吴阿麟 22 中国
>>>jack 12 USA
```
默认参数必须在最后面。
##### 关键参数
* 指定来参数名的参数为关键参数，关键参数必须放在位置参数后面
* 关键参数不能重复赋值
```
def sum(x,y,z,a=1):
    print(x,y,z,a)
sum(1,z=5,y=3) # 可正确调用

sum(1,z=5,4) # 错误调用（位置参数不能在关键参数后面）
sum(1,2,y=3) # 错误调用（参数不能重复赋值）
```
##### 非固定参数
* 如果形参中出现了‘*’，传递的参数就可以不再是固定个数，传过来的所有参数打包成元组

1. 方式一：
```
def send_alert(msg,*user)
    for i in user:
        print('报警！')
send_alert("传递内容",'alex','tom','jack') # *user可接收的参数个数是不固定的
```
2. 方式二：
```
send_alert("报警",*['alex','tom','jack'])
# 将列表中的参数原封不动打包传递到user参数中
# 如果没有列表前面的‘*’，则将列表打包到参数元组的第一个元素
```
'**'接受非固定参数，也就是没有在函数中定义的参数，将传入的参数打包成字典发送到两个星号的参数中
1. 方式一：
```
def sum(a,*b,**c):
	print(a,b,c)
sum(2,3,4,5,6,d=22,x=444,z=333)
>>>2 (3, 4, 5, 6) {'d': 22, 'x': 444, 'z': 333}
```
2. 方式二：
```
def sum(a,*b,**c):
	print(a,b,c)
s = {'str':'x'}
sum(2,**s)
>>>2 () {'str': 'x'}
```
##### 函数的返回值
* 函数外部的代码要想获取函数的执行结果，就可以在函数里用return语句把结果返回
注意：
1. 函数在执行过程中只要遇到return语句，就会停止执行并返回结果，so 也可以理解为 return 语句代表着函数的结束
2. 如果未在函数中指定return,那这个函数的返回值为None


##### 全局变量与局部变量
* 定义在函数外部一级代码的变量，叫全局变量，全局变量指整个程序可以用
* 在函数中定义的变量，叫局部变量
```
name = 'jack' # 全局变量
def change_name():
    name = 'tom' # 局部变量
    print(name)
chanfe_name()
print(name)
```
1. 局部变量只能在函数中调用，函数一旦执行完毕，局部变量失效
2. 在函数内部可以引用全局变量（在没有局部变量的时候）
3. 如果全局和局部都有一个变量，函数查找优先级由内而外

* 在局部变量中修改全局变量
```
name = 'jack' # 全局变量
def change_name():
    global name# 允许函数修改全局变量
    name = 'tom' # 局部变量
    print(name)
chanfe_name()
print(name)
```
1. global只能声明在修改之前
2. 不推荐使用global
* 在函数里修改列表数据
```
names = ['jack','tom',jom]
def change_name():
    del namse[2]
    print(names)
change_name()
print(names)
>>>['jack', 'tom']
>>>['jack', 'tom']
```
1. 列表、字典、对象在函数内部元素是可以修改的，但整体是不能修改的
2. 字符串，数字是不能被修改的

##### 嵌套函数
* 函数内部的函数，之后函数内部可以调用，嵌套函数中的变量选找函数中有没有对应变量，没有就往外找，最后是全局变量
* 嵌套函数必须要在上一层函数调用




##### 函数的作用域
* 在python中一个函数就是一个作用域
1. C# Java中的作用域{}
2. 所有的局部变量放置在其函数作用域中
3. 代码定义完成后，作用域已经生成，作用域链向上查找
4. 不论函数在哪调用，函数都会回到原来的作用域向上查找

##### 匿名函数
* 作用
1. 节省代码量
2. 看着高级
```
def calc(x,y):
    if  x < y:
        return x**y
    else:
        return x/y
func = lambda x,y: x*y if x<y else x/y #声明一个匿名函数
calc(16,8)
func(16,8)
```
##### 高阶函数
* 变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数
* 接受一个或多个函数作为输入
* return 返回另外一个函数
##### 递归
* 在函数的过程中调用自己
特性
1. 必须有一个明确的结束条件
2. 每次进入更深一层递归时，问题规模相比上次递归都应有所减少
3. 递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出）
##### 内置函数
pass

# 函数进阶
##### 命名空间
概念
##### 作用域的查找顺序
* L E G B
1. L:locas 局部
2. E:enclosing 相邻的作用域
3. G:globls 全局
4. B:builtins内置模块的名字空间
作用域的查找顺序就是先找函数内名字空间，包括局部变量和形参，然后找相邻也就是外部嵌套函数的名字空间然后找全局变量，函数定义所在模块的名字空间，最后找内置模块的名字空间
##### 闭包

##### 装饰器
还迷糊着

##### 生成器
列表生成式：
```
>>> a = list(range(10))
>>> a
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> a = [ i if i<5 else i*i for i in a ]
>>> a
[0, 1, 2, 3, 4, 25, 36, 49, 64, 81]
```
生成器语法与特性：
* 语法：
```
>>> a = (i for i in range(5))
>>> next(a)
0
>>> next(a)
1
>>> next(a)
2
````
* 特性
1. 只能往前走，不能后退或者修改
2. 需要取值只能next
3. 生成完了报错

函数创建生成器：

yield vs return

* return ：返回并终止
* yield ：返回数据，并冻结当前的执行过程，要使函数继续执行，继续使用next（唤醒冻结的函数执行过程，继续执行，直到遇到下一个yidle）

```
def range2(n):
	count = 0
	while count<n:
		print(count)
		count+=1
		yield count  # return   将函数变成生成器

new_range = range2(10)
next(new_range) # 生成器调用语法

```
* 函数有了yield之后
1. 函数名+（）就得到了一个生成器
2. return 在生成器里，代表生成器的终止，直接报错


send（）
```
def range2(n):
	count = 0
	while count<n:
		print(count)
		count+=1
		yield count  #return   将函数变成生成器

new_range = range2(3)
next(new_range) #生成器调用语法

print("结束")

new_range.send("stop")

```
1. 唤醒并继续执行
2. 发送一个信息到生成器内部
3.
##### 迭代器
* 可以被next（）函数调用并不断返回下一 个值的对象称为迭代器：Itertor

